# rust helloworld

个人rust学习练习项目。

## 笔记总结

### 所有权与借用

引用分可变引用与不可变引用，只有可变引用才可以修改对应的值。

引用的引用的作用域从创建开始，一直持续到它最后一次使用的地方，这个跟变量的作用域有所不同，变量的作用域从创建持续到某一个花括号 。

可变引用同时只能存在一个（一个可变引用的作用域内，不能存在指向同一个变量的另一个可变引用）

可变引用与不可变引用不能同时存在

编译器会确保数据不会在其引用之前被释放，想释放数据，必须停止使用引用。避免了悬垂引用的问题（dangling reference）

* 同一时刻要么拥有一个可变引用，要么拥有任意多个不可变引用
* 引用必须是有效的

### 复合类型

只使用基本类型的局限性：无法从更高层次来简化代码。

字符串（String）以及字符串切片（&str）。字面量字符串本质是切片。字符串使用UTF-8编码。Rust不允许索引字符串。对字符串进行切片非常危险，无法保证索引的字节正好位于字符的边界上。

字面值str不可变，性能快速且高效。而String类型是程序运行中生成的，大小不可预知，需要请求内存存放string，并且使用完成后要归还。

你只能将 String 跟 &str 类型进行拼接，并且 String 的所有权在此过程中会被 move.

与 str 的很少使用相比，&str 和 String 类型却非常常用，因此也非常重要。

> 对于 Rust 而言，安全和性能是写到骨子里的核心特性，如果使用 GC，那么会牺牲性能；如果使用手动管理内存，那么会牺牲安全，这该怎么办？为此，Rust 的开发者想出了一个无比惊艳的办法：变量在离开作用域后，就自动释放其占用的内存

#### 元组

多种类型组合在一起的，长度固定，元组中的元素顺序也是固定的。

模式匹配解构元组：用同样的形式把一个复杂对象中的值匹配出来。

#### 结构体

必须将结构体声明为可变的，才能修改其中的字段，rust不支持将某个结构体某个字段标记为可变。

初始化结构体时，必须初始化每个字段。

结构体可以简化创建，变量名和结构体名相同时，可以直接使用。

更新结构体的时候，可以将已有结构体传入新结构体内部来简化更新。结构体更新赋值的时候，可能会转移所有权。

元组结构体，字段没有名称，长得很像元组。

单元结构体类似单元类型。没有任何字段和属性。

在结构体中使用引用，必须加上生命周期标识符。

#### 枚举
枚举类型是一个类型，会包含每一个可能的枚举成员，而枚举值是该类型中的某个成员的实例。

枚举成员还可以直接关联数据，不仅如此，同一个枚举类型下的不同成员还可以持有不同的数据类型（Java不允许这么做）。可以同一化类型。

Option枚举用来处理空值，rust抛弃了null值，而改为使用Option枚举变量来表述这种结果，Option有两个成员，一个是Some表示有值，一个是None表示没有值。

Some和None无需使用Option:: 就可以使用。通过Some包装后的值，不能直接与原值进行交互，因为属于不同的类型，这样的包装有利于解决隐藏的空指针问题。要进行运算必须转换类型为T（各种unwrap方法）

Match表达式可以使用匹配模式识别枚举的成员，根据不同的成员使用不同的逻辑。

#### 数组
Array 速度很快但长度固定， Vector（动态数组）可以动态增长但是有性能损耗。

Array和Vector的关系与&str和String 的关系很像，前者是固定长度的字符串切片，后者是可动态增长的字符串。

数组必须满足 长度固定，类型相同，线性排列这三个条件，因此array是可以储存在栈内存上的。

数组切片，允许引用部分连续的片段，使用切片引用类型&[T]


